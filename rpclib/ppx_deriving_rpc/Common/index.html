<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Common (ppx_deriving_rpc.Common)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_deriving_rpc</a> &#x00BB; Common</nav><header class="odoc-preamble"><h1>Module <code><span>Common</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-list_assoc_find_exn" class="anchored"><a href="#val-list_assoc_find_exn" class="anchor"></a><code><span><span class="keyword">val</span> list_assoc_find_exn : 
  <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>equal:<span>( <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'f</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-list_assoc_mem" class="anchored"><a href="#val-list_assoc_mem" class="anchor"></a><code><span><span class="keyword">val</span> list_assoc_mem : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>equal:<span>( <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_concat" class="anchored"><a href="#val-string_concat" class="anchor"></a><code><span><span class="keyword">val</span> string_concat : <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_split_on_chars" class="anchored"><a href="#val-string_split_on_chars" class="anchor"></a><code><span><span class="keyword">val</span> string_split_on_chars : <span>string <span class="arrow">&#45;&gt;</span></span> <span>on:<span><span class="xref-unresolved">Stdlib</span>.Char.t list</span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_whitespace" class="anchored"><a href="#val-is_whitespace" class="anchor"></a><code><span><span class="keyword">val</span> is_whitespace : <span>char <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-string_strip" class="anchored"><a href="#val-string_strip" class="anchor"></a><code><span><span class="keyword">val</span> string_strip : <span>?drop:<span>( <span>char <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-list_partition_tf" class="anchored"><a href="#val-list_partition_tf" class="anchor"></a><code><span><span class="keyword">val</span> list_partition_tf : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> list</span> * <span><span class="type-var">'d</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-core_types" class="anchored"><a href="#val-core_types" class="anchor"></a><code><span><span class="keyword">val</span> core_types : <span><span class="xref-unresolved">Ppxlib</span>.location <span class="arrow">&#45;&gt;</span></span> <span><span>(string * <span class="xref-unresolved">Ppxlib</span>.expression)</span> list</span></span></code></div></div><p>Many of the following functions are lifted from ppx_deriving. It's quite likely that there are good alternatives to these somewhere in ppxlib, but I've not yet found them.</p><p>They are used to deal with parameterised types. When declaring a function derived from a parameterised type, the function will be extended to take an argument for each type parameter. The important functions below are `poly_fun_of_type_decl` and `poly_apply_of_type_decl` - for declaring and using the derived functions respectively.</p><div class="odoc-spec"><div class="spec value" id="val-fold_right_type_params" class="anchored"><a href="#val-fold_right_type_params" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_type_params : 
  <span><span>( <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="xref-unresolved">Ppxlib</span>.core_type * <span class="type-var">'c</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'e</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_right_type_decl" class="anchored"><a href="#val-fold_right_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_type_decl : 
  <span><span>( <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib</span>.type_declaration <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold_right_type_decl fn accum type_</code> performs a right fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-poly_fun_of_type_decl" class="anchored"><a href="#val-poly_fun_of_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> poly_fun_of_type_decl : 
  <span>loc:<span class="xref-unresolved">Ppxlib__</span>.Import.location <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib</span>.type_declaration <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib__</span>.Import.expression <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppxlib__</span>.Import.expression</span></code></div><div class="spec-doc"><p><code>poly_fun_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>fun poly_N -&gt; ...</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>fun poly_a poly_b -&gt; [%e expr]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_type_params" class="anchored"><a href="#val-fold_left_type_params" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_type_params : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="xref-unresolved">Ppxlib</span>.core_type * <span class="type-var">'d</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'e</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_type_decl" class="anchored"><a href="#val-fold_left_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_type_decl : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib</span>.type_declaration <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>fold_left_type_decl fn accum type_</code> performs a left fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-poly_apply_of_type_decl" class="anchored"><a href="#val-poly_apply_of_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> poly_apply_of_type_decl : 
  <span>loc:<span class="xref-unresolved">Ppxlib__</span>.Location.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib</span>.type_declaration <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Astlib</span>.Ast_412.Parsetree.expression <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Astlib</span>.Ast_412.Parsetree.expression</span></code></div><div class="spec-doc"><p><code>poly_apply_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>expr poly_N</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>[%e expr] poly_a poly_b</code>. <code>_</code> parameters are ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expr_of_option" class="anchored"><a href="#val-expr_of_option" class="anchor"></a><code><span><span class="keyword">val</span> expr_of_option : 
  <span>loc:<span class="xref-unresolved">Ppxlib</span>.location <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Ppxlib</span>.expression option</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppxlib</span>.expression</span></code></div><div class="spec-doc"><p><code>expr_of_option ~loc o</code> turns an optional expression into an expression of an optional value. In several places there are optional attributes, e.g. <code>@@version foo</code>, which end up as values of type `expression option`. These are often turned into optional values in the generated code.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Attrs" class="anchored"><a href="#module-Attrs" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Attrs/index.html">Attrs</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Typed attribute getters</p></div></div><div class="odoc-spec"><div class="spec value" id="val-attr" class="anchored"><a href="#val-attr" class="anchor"></a><code><span><span class="keyword">val</span> attr : 
  <span><span class="xref-unresolved">Ppxlib__</span>.Location.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.String.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Ppxlib</span>.attribute list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-convert_doc" class="anchored"><a href="#val-convert_doc" class="anchor"></a><code><span><span class="keyword">val</span> convert_doc : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-get_doc" class="anchored"><a href="#val-get_doc" class="anchor"></a><code><span><span class="keyword">val</span> get_doc : 
  <span>loc:<span class="xref-unresolved">Ppxlib__</span>.Location.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Ppxlib__</span>.Import.expression option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Ppxlib</span>.attributes <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppxlib__</span>.Import.expression</span></code></div><div class="spec-doc"><p><code>get_doc loc rpcdoc attrs</code> extracts documentation from the type declarations. rpcdoc is the result of looking for @doc tags. If this is found, we use that. If not, we look for ocamldoc docstrings and return them instead. In both cases, the result is an expression of type list</p></div></div></div></body></html>