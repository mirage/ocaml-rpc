<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Common (ppx_deriving_rpc.Common)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ppx_deriving_rpc</a> &#x00BB; Common</nav><h1>Module <code>Common</code></h1></header><dl><dt class="spec value" id="val-list_assoc_find_exn"><a href="#val-list_assoc_find_exn" class="anchor"></a><code><span class="keyword">val</span> list_assoc_find_exn : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span>equal:<span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-list_assoc_mem"><a href="#val-list_assoc_mem" class="anchor"></a><code><span class="keyword">val</span> list_assoc_mem : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span>equal:<span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-string_concat"><a href="#val-string_concat" class="anchor"></a><code><span class="keyword">val</span> string_concat : <span>?&#8288;sep:string</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-string_split_on_chars"><a href="#val-string_split_on_chars" class="anchor"></a><code><span class="keyword">val</span> string_split_on_chars : string <span>&#45;&gt;</span> <span>on:<span>Stdlib.Char.t list</span></span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dt class="spec value" id="val-is_whitespace"><a href="#val-is_whitespace" class="anchor"></a><code><span class="keyword">val</span> is_whitespace : char <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-string_strip"><a href="#val-string_strip" class="anchor"></a><code><span class="keyword">val</span> string_strip : <span>?&#8288;drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-list_partition_tf"><a href="#val-list_partition_tf" class="anchor"></a><code><span class="keyword">val</span> list_partition_tf : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></code></dt><dt class="spec value" id="val-core_types"><a href="#val-core_types" class="anchor"></a><code><span class="keyword">val</span> core_types : Ppxlib.location <span>&#45;&gt;</span> <span><span>(string * Ppxlib.expression)</span> list</span></code></dt></dl><aside><p>Many of the following functions are lifted from ppx_deriving. It's quite likely that there are good alternatives to these somewhere in ppxlib, but I've not yet found them.</p><p>They are used to deal with parameterised types. When declaring a function derived from a parameterised type, the function will be extended to take an argument for each type parameter. The important functions below are `poly_fun_of_type_decl` and `poly_apply_of_type_decl` - for declaring and using the derived functions respectively.</p></aside><dl><dt class="spec value" id="val-fold_right_type_params"><a href="#val-fold_right_type_params" class="anchor"></a><code><span class="keyword">val</span> fold_right_type_params : <span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(Ppxlib.core_type * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_right_type_decl"><a href="#val-fold_right_type_decl" class="anchor"></a><code><span class="keyword">val</span> fold_right_type_decl : <span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right_type_decl fn accum type_</code> performs a right fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-poly_fun_of_type_decl"><a href="#val-poly_fun_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> poly_fun_of_type_decl : <span>loc:Ppxlib__.Import.location</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Ppxlib__.Import.expression <span>&#45;&gt;</span> Ppxlib__.Import.expression</code></dt><dd><p><code>poly_fun_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>fun poly_N -&gt; ...</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>fun poly_a poly_b -&gt; [%e expr]</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_left_type_params"><a href="#val-fold_left_type_params" class="anchor"></a><code><span class="keyword">val</span> fold_left_type_params : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(Ppxlib.core_type * <span class="type-var">'b</span>)</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-fold_left_type_decl"><a href="#val-fold_left_type_decl" class="anchor"></a><code><span class="keyword">val</span> fold_left_type_decl : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left_type_decl fn accum type_</code> performs a left fold over all type variable (i.e. not wildcard) parameters in <code>type_</code>.</p></dd></dl><dl><dt class="spec value" id="val-poly_apply_of_type_decl"><a href="#val-poly_apply_of_type_decl" class="anchor"></a><code><span class="keyword">val</span> poly_apply_of_type_decl : <span>loc:Ppxlib__.Location.t</span> <span>&#45;&gt;</span> Ppxlib.type_declaration <span>&#45;&gt;</span> Migrate_parsetree.Ast_412.Parsetree.expression <span>&#45;&gt;</span> Migrate_parsetree.Ast_412.Parsetree.expression</code></dt><dd><p><code>poly_apply_of_type_decl type_ expr</code> wraps <code>expr</code> into <code>expr poly_N</code> for every type parameter <code>'N</code> present in <code>type_</code>. For example, if <code>type_</code> refers to <code>type ('a, 'b) map</code>, <code>expr</code> will be wrapped into <code>[%e expr] poly_a poly_b</code>. <code>_</code> parameters are ignored.</p></dd></dl><dl><dt class="spec value" id="val-expr_of_option"><a href="#val-expr_of_option" class="anchor"></a><code><span class="keyword">val</span> expr_of_option : <span>loc:Ppxlib.location</span> <span>&#45;&gt;</span> <span>Ppxlib.expression option</span> <span>&#45;&gt;</span> Ppxlib.expression</code></dt><dd><p><code>expr_of_option ~loc o</code> turns an optional expression into an expression of an optional value. In several places there are optional attributes, e.g. <code>@@version foo</code>, which end up as values of type `expression option`. These are often turned into optional values in the generated code.</p></dd></dl><dl><dt class="spec module" id="module-Attrs"><a href="#module-Attrs" class="anchor"></a><code><span class="keyword">module</span> <a href="Attrs/index.html">Attrs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Typed attribute getters</p></dd></dl><dl><dt class="spec value" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span class="keyword">val</span> attr : Ppxlib__.Location.t <span>&#45;&gt;</span> Stdlib.String.t <span>&#45;&gt;</span> <span>Ppxlib.attribute list</span> <span>&#45;&gt;</span> <span>string option</span></code></dt><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : string <span>&#45;&gt;</span> <span>string list</span></code></dt><dt class="spec value" id="val-convert_doc"><a href="#val-convert_doc" class="anchor"></a><code><span class="keyword">val</span> convert_doc : string <span>&#45;&gt;</span> <span>string list</span></code></dt><dt class="spec value" id="val-get_doc"><a href="#val-get_doc" class="anchor"></a><code><span class="keyword">val</span> get_doc : <span>loc:Ppxlib__.Location.t</span> <span>&#45;&gt;</span> <span>Ppxlib__.Import.expression option</span> <span>&#45;&gt;</span> Ppxlib.attributes <span>&#45;&gt;</span> Ppxlib__.Import.expression</code></dt><dd><p><code>get_doc loc rpcdoc attrs</code> extracts documentation from the type declarations. rpcdoc is the result of looking for @doc tags. If this is found, we use that. If not, we look for ocamldoc docstrings and return them instead. In both cases, the result is an expression of type list</p></dd></dl></div></body></html>