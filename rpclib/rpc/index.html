<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (rpc.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – rpc</nav><header class="odoc-preamble"><h1 id="ocaml-rpc----remote-procedure-calls-(rpc)-library"><a href="#ocaml-rpc----remote-procedure-calls-(rpc)-library" class="anchor"></a>OCaml-RPC -- remote procedure calls (RPC) library</h1><p><code>ocaml-rpc</code> is a library that provides remote procedure calls (RPC) using XML or JSON as transport encodings. The transport mechanism itself is outside the scope of this library as all conversions are from and to strings. The <code>odoc</code> generated documentation is available at <a href="http://mirage.github.io/ocaml-rpc/rpclib/index.html">mirage.github.io/ocaml-rpc/rpclib</a>.</p><p><a href="https://travis-ci.org/mirage/ocaml-rpc"> <img src="https://travis-ci.org/mirage/ocaml-rpc.svg?branch=master" alt="Build Status"/></a></p></header><nav class="odoc-toc"><ul><li><a href="#rpc-types">RPC types</a></li><li><a href="#generating-code">Generating code</a></li><li><a href="#conversion-functions">Conversion functions</a></li><li><a href="#idl-generator">IDL generator</a></li><li><a href="#base64-decoding">Base64 Decoding</a></li><li><a href="#building">Building</a></li></ul></nav><div class="odoc-content"><h2 id="rpc-types"><a href="#rpc-types" class="anchor"></a>RPC types</h2><p>An RPC value is defined as follow:</p><pre><code>type t =
    Int of int64
  | Int32 of int32
  | Bool of bool
  | Float of float
  | String of string
  | DateTime of string
  | Enum of t list
  | Dict of (string * t) list
  | Base64 of string
  | Null</code></pre><h2 id="generating-code"><a href="#generating-code" class="anchor"></a>Generating code</h2><p>The idea behind <code>ocaml-rpc</code> is to generate type definitions that can be used to convert values of a given type to and from their RPC representations.</p><p>In order to do so, it is sufficient to add <code>[@@deriving rpcty]</code> to the corresponding type definition. Hence :</p><pre><code>type t = ... [@@deriving rpcty]</code></pre><p>This will give a value <code>typ_of_t</code> of type <code>Rpc.Types.typ</code>, which can be used in conjunction with the <code>Rpcmarshal</code> module to:</p><ul><li><p>Convert values of type <code>t</code> to values of type <code>Rpc.t</code>:</p><pre><code>let rpc_of_t t = Rpcmarshal.marshal typ_of_t t</code></pre></li><li><p>Convert values of type <code>Rpc.t</code> to values of type <code>t</code> :</p><pre><code>let t_of_rpc rpc = Rpcmarshal.unmarshal typ_of_t rpc</code></pre></li></ul><p>Optionally, it is possible to have different field name in the OCaml type (if it is a record) and in the dictionary argument (the first elements of <code>Dict</code>):</p><pre><code>type t = { foo: int [@key &quot;type&quot;]; bar: int [@key &quot;let&quot;]; } [@@deriving rpcty]</code></pre><p>This will replace &quot;foo&quot; by &quot;type&quot; and &quot;bar&quot; by &quot;let&quot; in the RPC representation. This is particularly useful when you want to integrate with an existing API and the field names are not valid OCaml identifiers.</p><p>The library also provides the <code>[@@deriving rpc]</code> ppx, which is similar to <code>rpcty</code>, but directly generates the conversion functions.</p><pre><code>type t = ... [@@deriving rpc]</code></pre><p>will give two functions:</p><ul><li>A function to convert values of type <code>t</code> to values of type <code>Rpc.t</code> : <code>val rpc_of_t : t -&gt; Rpc.t</code></li><li>A function to convert values of type <code>Rpc.t</code> to values of type <code>t</code> : <code>val t_of_rpc : Rpc.t -&gt; (t,string) Result.t</code></li></ul><p>It also supports the <code>@key</code> annotations for having different field names:</p><pre><code>type t = { foo: int [@key &quot;type&quot;]; bar: int [@key &quot;let&quot;]; } [@@deriving rpc]</code></pre><h2 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h2><p><code>ocaml-rpc</code> currently support two protocols: XMLRPC and JSON(RPC). Function signatures are:</p><pre><code>val Xmlrpc.to_string : Rpc.t -&gt; string
val Xmlrpc.of_string : string -&gt; Rpc.t
val Jsonrpc.to_string : Rpc.t -&gt; string
val Jsonrpc.of_string : string -&gt; Rpc.t</code></pre><p>So if you want to marshal a value x of type t to JSON, you can use the following function:</p><pre><code>Jsonrpc.to_string (rpc_of_t x)</code></pre><h2 id="idl-generator"><a href="#idl-generator" class="anchor"></a>IDL generator</h2><p>The <code>Idl</code> module makes it possible to define an abstract interface in OCaml using the following pattern:</p><pre><code>module CalcInterface(R : Idl.RPC) = struct
  open R

  let int_p = Idl.Param.mk Rpc.Types.int

  let add = R.declare &quot;add&quot;
      [&quot;Add two numbers&quot;]
      (int_p @-&gt; int_p @-&gt; returning int_p Idl.DefaultError.err)

  let mul = R.declare &quot;mul&quot;
      [&quot;Multiply two numbers&quot;]
      (int_p @-&gt; int_p @-&gt; returning int_p Idl.DefaultError.err)

  let implementation = implement
      { Idl.Interface.name = &quot;Calc&quot;; namespace = Some &quot;Calc&quot;; description = [&quot;Calculator supporting addition and multiplication&quot;]; version = (1,0,0) }
end</code></pre><p>Then we can generate various &quot;bindings&quot; from it by passing a module implementing the <code>RPC</code> signature to this functor:</p><ul><li><p>OCaml bindings for clients or servers can be generated using one of the <code>GenClient*</code> or <code>GenServer*</code> functors, respectively.</p><p>For example one can generate an RPC client this way:</p><pre><code>module CalcClient :
  sig
    val add :
      (Rpc.call -&gt; Rpc.response) -&gt;
      int -&gt; int -&gt; (int, Idl.DefaultError.t) result
    val mul :
      (Rpc.call -&gt; Rpc.response) -&gt;
      int -&gt; int -&gt; (int, Idl.DefaultError.t) result
  end = CalcInterface(Idl.GenClient ())</code></pre><p>The functions in the resulting <code>CalcClient</code> module can be used to call their corresponding RPC methods. <code>CalcClient</code> does not implement the transport mechanism itself, that should be provided by passing an a rpc function of type <code>Rpc.call -&gt; Rpc.response</code>.</p><p><code>CalcClient.add rpc 4 5</code> will marshal the parameters <code>4</code> and <code>5</code> into their RPC representations, construct an <code>Rpc.call</code>, pass that call to the given <code>rpc</code> function, and return either an <code>Ok</code> containing the unmarshalled result or an <code>Error</code> with the error description depending on the response returned by <code>rpc</code>.</p><p>There are variations of the <code>GenClient</code> module:</p><p><code>GenClientExn</code> raises an exception in case the response indicates a failure, instead of returning a <code>result</code>:</p><pre><code>module CalcClient :
  sig
    val add : (Rpc.call -&gt; Rpc.response) -&gt; int -&gt; int -&gt; int
    val mul : (Rpc.call -&gt; Rpc.response) -&gt; int -&gt; int -&gt; int
  end = CalcInterface(Idl.GenClientExn ())</code></pre><p>and <code>GenClientExnRpc</code> allows one to specify the rpc function once when constructing the client module:</p><pre><code>module CalcClient :
  sig
    val add : int -&gt; int -&gt; int
    val mul : int -&gt; int -&gt; int
  end = CalcInterface(Idl.GenClientExnRpc (struct let rpc = rpc end))</code></pre><p>Bindings for a server can be generated in a similar way:</p><pre><code>module CalcServer :
  sig
    val add : (int -&gt; int -&gt; (int, Idl.DefaultError.t) result) -&gt; unit
    val mul : (int -&gt; int -&gt; (int, Idl.DefaultError.t) result) -&gt; unit
    val implementation : Idl.server_implementation
  end = CalcInterface(Idl.GenServer ())</code></pre><p>The implementations of each RPC method should be specified by passing it to the corresponding function in <code>CalcServer</code>:</p><pre><code>CalcServer.add (fun a b -&gt; Ok (a + b));
CalcServer.mul (fun a b -&gt; Ok (a * b));</code></pre><p>Then we can generate our server from the <code>implementation</code> (in case of <code>GenClient</code>, <code>implementation</code> is unused):</p><pre><code>let rpc : (Rpc.call -&gt; Rpc.response) = Idl.server CalcServer.implementation</code></pre><p>Again, the transport mechanism is not implemented by <code>CalcServer</code>. We just get an rpc function that, given an <code>Rpc.call</code>, calls the implementation of that RPC method and performs the marshalling and unmarshalling. It is up to the user of this library to connect this <code>rpc</code> function to a real server that responds to client requests.</p><p>Here we also have a <code>GenServerExn</code> functor, for server implementations that raise exceptions instead of returning a <code>result</code>.</p><p>The <code>rpclib-lwt</code> and <code>rpclib-async</code> packages provide similar client and server generators that use <code>Lwt</code> and <code>Async</code>, respectively.</p><p>The <code>Xmlrpc</code> and <code>Jsonrpc</code> modules can be helpful when implementing the <code>rpc</code> function for an XML-RPC or JSON-RPC client/server: they provide functions for converting rpc requests and responses to/from their respective wire formats.</p></li><li><p>Commandline interfaces can be generated using <code>Cmdlinergen</code>:</p><pre><code>module CalcCli :
  sig
    val implementation :
      unit -&gt;
      ((Rpc.call -&gt; Rpc.response) -&gt;
       (unit -&gt; unit) Cmdliner.Term.t * Cmdliner.Term.info)
      list
  end = CalcInterface(Cmdlinergen.Gen ())</code></pre><p>We can use the <code>implementation</code> to construct the CLI. Again, we need to pass an <code>rpc</code> function that knows how to make RPC calls.</p><pre><code>let () =
  let cmds = (List.map (fun t -&gt; t rpc) (CalcCli.implementation ())) in
  let open Cmdliner in
  Term.(exit @@ eval_choice default_cmd cmds)</code></pre></li><li><p>Some generators use the output of <code>Codegen</code>. This functor generates a structure that contains information about the methods, their parameters, return types, etc. Currently these generators that use the output of <code>Codegen</code> require the method parameters to be named.</p><pre><code>module CalcInterface(R : Idl.RPC) = struct
  open R

  let int_p_1 = Idl.Param.mk ~name:&quot;int1&quot; Rpc.Types.int
  let int_p_2 = Idl.Param.mk ~name:&quot;int2&quot; Rpc.Types.int
  let int_p = Idl.Param.mk Rpc.Types.int

  let add = R.declare &quot;add&quot;
      [&quot;Add two numbers&quot;]
      (int_p_1 @-&gt; int_p_2 @-&gt; returning int_p Idl.DefaultError.err)

  let implementation = implement
      { Idl.Interface.name = &quot;Calc&quot;; namespace = Some &quot;Calc&quot;; description = [&quot;Calculator supporting addition and multiplication&quot;]; version = (1,0,0) }
end

module CalcCode :
  sig
    val implementation : unit -&gt; Codegen.Interface.t
  end = CalcInterface(Codegen.Gen ())

let interfaces = Codegen.Interfaces.create
  ~name:&quot;calc&quot;
  ~title:&quot;Calculator&quot;
  ~description:[&quot;Interface for a Calculator&quot;]
  ~interfaces:[CalcCode.implementation ()]</code></pre><ul><li><p><code>Markdowngen</code> can generate a markdown file documenting these interfaces:</p><pre><code>let md = Markdowngen.to_string interfaces</code></pre></li><li><p><code>Pythongen</code> can generate Python code that contains various classes wrapping a Python implementation, providing typechecking &amp; method dispatch, and a CLI.</p><pre><code>let code = Pythongen.of_interfaces interfaces |&gt; Pythongen.string_of_ts</code></pre></li></ul></li></ul><p>The possibilities are not limited to the above generators provided by <code>ocaml-rpc</code>. Any third-party module implementing the <code>RPC</code> signature can be used to generate something from an interface defined following the above pattern. For example, it is possible to write an <code>RPC</code> implementation that generates a GUI for a given interface.</p><h2 id="base64-decoding"><a href="#base64-decoding" class="anchor"></a>Base64 Decoding</h2><p>The treatment of line feeds (and other characters) in <a href="http://xmlrpc.com">XML-RPC</a> base64-encoded data is underspecified.</p><p>By default, this library decodes values using the <code>Base64.decode_exn</code> function of <a href="https://github.com/mirage/ocaml-base64">ocaml-base64</a>. This function implements <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC4648</a> which requires the rejection of non-alphabet characters for security reasons (see <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-3.3">section 3.3</a> and also <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-3.1">section 3.1</a>).</p><p>This is problematic when communicating with servers that are less strict. For instance, the <a href="https://docs.python.org/3/library/xmlrpc.client.html#xmlrpc.client.Binary.encode">encode</a> function of the Python <code>xmlrpc.client</code> refers to <a href="https://datatracker.ietf.org/doc/html/rfc2045.html#section-6.8">section 6.8 of RFC2045</a> to justify inserting a newline character every 76 characters. For this reasons, the functions in <code>Xmlrpc</code> allow the caller to override the <code>base64_decoder</code>. The following declaration gives a rough-and-ready “dangerous” implementation based on the <code>Base64.rfc2045</code> package. A better implementation would only accept a <code>\n</code> every 76 characters.</p><pre><code>let base64_2045_decoder s =
  let open Base64_rfc2045 in
  let buf = Buffer.create 1024 in
  let d = decoder (`String s) in
  let rec go () =
    match decode d with
    | `Flush s -&gt; (Buffer.add_string buf s; go ())
    | `End -&gt; Buffer.contents buf
    (* best-effort *)
    | `Malformed _   (* ignore missing '\r' before '\n', etc. *)
    | `Wrong_padding (* ignore *)
    | `Await -&gt; go ()
  in
  go ()</code></pre><h2 id="building"><a href="#building" class="anchor"></a>Building</h2><p>To build, first install the dependencies:</p><pre><code>opam install dune base64 ppxlib async js_of_ocaml-ppx lwt cow cmdliner rresult yojson xmlm</code></pre><p>For tests:</p><pre><code>opam install alcotest alcotest-lwt</code></pre></div></body></html>