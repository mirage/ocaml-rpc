<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (rpc.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ rpc</nav><nav class="toc"><ul><li><a href="#ocaml-rpc----remote-procedure-calls-\(rpc\)-library">OCaml-RPC -- remote procedure calls \(RPC\) library</a><ul><li><a href="#rpc-types">RPC types</a></li><li><a href="#generating-code">Generating code</a></li><li><a href="#conversion-functions">Conversion functions</a></li><li><a href="#idl-generator">IDL generator</a></li></ul></li></ul></nav></header><h4 id="ocaml-rpc----remote-procedure-calls-\(rpc\)-library"><a href="#ocaml-rpc----remote-procedure-calls-\(rpc\)-library" class="anchor"></a>OCaml-RPC -- remote procedure calls \(RPC\) library</h4><p><code>ocaml-rpc</code> is a library that provides remote procedure calls \(RPC\) using XML or JSON as transport encodings. The transport mechanism itself is outside the scope of this library as all conversions are from and to strings. The <code>odoc</code> generated documentation is available at <a href="http://mirage.github.io/ocaml-rpc/rpclib/index.html">mirage.github.io/ocaml-rpc/rpclib</a>.</p><p><a href="https://travis-ci.org/mirage/ocaml-rpc"> <img src="https://travis-ci.org/mirage/ocaml-rpc.svg?branch=master" alt="Build Status"></img></a></p><h5 id="rpc-types"><a href="#rpc-types" class="anchor"></a>RPC types</h5><p>An RPC value is defined as follow:</p><pre><code class="ml">type t =
    Int of int64
  | Int32 of int32
  | Bool of bool
  | Float of float
  | String of string
  | DateTime of string
  | Enum of t list
  | Dict of (string * t) list
  | Base64 of string
  | Null</code></pre><h5 id="generating-code"><a href="#generating-code" class="anchor"></a>Generating code</h5><p>The idea behind <code>ocaml-rpc</code> is to generate type definitions that can be used to convert values of a given type to and from their RPC representations.</p><p>In order to do so, it is sufficient to add <code>[@@deriving rpcty]</code> to the corresponding type definition. Hence :</p><pre><code class="ml">type t = ... [@@deriving rpcty]</code></pre><p>This will give a value <code>typ_of_t</code> of type <code>Rpc.Types.typ</code>, which can be used in conjunction with the <code>Rpcmarshal</code> module to:</p><ul><li><p>Convert values of type <code>t</code> to values of type <code>Rpc.t</code>:</p><pre><code class="ml">let rpc_of_t t = Rpcmarshal.marshal typ_of_t t</code></pre></li><li><p>Convert values of type <code>Rpc.t</code> to values of type <code>t</code> :</p><pre><code class="ml">let t_of_rpc rpc = Rpcmarshal.unmarshal typ_of_t rpc</code></pre></li></ul><p>Optionally, it is possible to have different field name in the OCaml type \(if it is a record\) and in the dictionary argument \(the first elements of <code>Dict</code>\):</p><pre><code class="ml">type t = { foo: int [@key &quot;type&quot;]; bar: int [@key &quot;let&quot;]; } [@@deriving rpcty]</code></pre><p>This will replace &quot;foo&quot; by &quot;type&quot; and &quot;bar&quot; by &quot;let&quot; in the RPC representation. This is particularly useful when you want to integrate with an existing API and the field names are not valid OCaml identifiers.</p><p>The library also provides the <code>[@@deriving rpc]</code> ppx, which is similar to <code>rpcty</code>, but directly generates the conversion functions.</p><pre><code class="ml">type t = ... [@@deriving rpc]</code></pre><p>will give two functions:</p><ul><li>A function to convert values of type <code>t</code> to values of type <code>Rpc.t</code> : <code>val rpc_of_t : t -&gt; Rpc.t</code></li><li>A function to convert values of type <code>Rpc.t</code> to values of type <code>t</code> : <code>val t_of_rpc : Rpc.t -&gt; (t,string) Result.result</code></li></ul><p>It also supports the <code>@key</code> annotations for having different field names:</p><pre><code class="ml">type t = { foo: int [@key &quot;type&quot;]; bar: int [@key &quot;let&quot;]; } [@@deriving rpc]</code></pre><h5 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h5><p><code>ocaml-rpc</code> currently support two protocols: XMLRPC and JSON\(RPC\). Function signatures are:</p><pre><code class="ml">val Xmlrpc.to_string : Rpc.t -&gt; string
val Xmlrpc.of_string : string -&gt; Rpc.t
val Jsonrpc.to_string : Rpc.t -&gt; string
val Jsonrpc.of_string : string -&gt; Rpc.t</code></pre><p>So if you want to marshal a value x of type t to JSON, you can use the following function:</p><pre><code class="ml">Jsonrpc.to_string (rpc_of_t x)</code></pre><h5 id="idl-generator"><a href="#idl-generator" class="anchor"></a>IDL generator</h5><p>The <code>Idl</code> module makes it possible to define an abstract interface in OCaml using the following pattern:</p><pre><code class="ml">module CalcInterface(R : Idl.RPC) = struct
  open R

  let int_p = Idl.Param.mk Rpc.Types.int

  let add = R.declare &quot;add&quot;
      [&quot;Add two numbers&quot;]
      (int_p @-&gt; int_p @-&gt; returning int_p Idl.DefaultError.err)

  let mul = R.declare &quot;mul&quot;
      [&quot;Multiply two numbers&quot;]
      (int_p @-&gt; int_p @-&gt; returning int_p Idl.DefaultError.err)

  let implementation = implement
      { Idl.Interface.name = &quot;Calc&quot;; namespace = Some &quot;Calc&quot;; description = [&quot;Calculator supporting addition and multiplication&quot;]; version = (1,0,0) }
end</code></pre><p>Then we can generate various &quot;bindings&quot; from it by passing a module implementing the <code>RPC</code> signature to this functor:</p><ul><li>OCaml bindings for clients or servers can be generated using one of the <code>GenClient*</code> or <code>GenServer*</code> functors, respectively.</li></ul><p>For example one can generate an RPC client this way:</p><pre><code class="ml">module CalcClient :
  sig
    val add :
      (Rpc.call -&gt; Rpc.response) -&gt;
      int -&gt; int -&gt; (int, Idl.DefaultError.t) result
    val mul :
      (Rpc.call -&gt; Rpc.response) -&gt;
      int -&gt; int -&gt; (int, Idl.DefaultError.t) result
  end = CalcInterface(Idl.GenClient ())</code></pre><p>The functions in the resulting <code>CalcClient</code> module can be used to call their corresponding RPC methods. <code>CalcClient</code> does not implement the transport mechanism itself, that should be provided by passing an a rpc function of type <code>Rpc.call -&gt; Rpc.response</code>.</p><p><code>CalcClient.add rpc 4 5</code> will marshal the parameters <code>4</code> and <code>5</code> into their RPC representations, construct an <code>Rpc.call</code>, pass that call to the given <code>rpc</code> function, and return either an <code>Ok</code> containing the unmarshalled result or an <code>Error</code> with the error description depending on the response returned by <code>rpc</code>.</p><p>There are variations of the <code>GenClient</code> module:</p><p><code>GenClientExn</code> raises an exception in case the response indicates a failure, instead of returning a <code>result</code>:</p><pre><code class="ml">module CalcClient :
  sig
    val add : (Rpc.call -&gt; Rpc.response) -&gt; int -&gt; int -&gt; int
    val mul : (Rpc.call -&gt; Rpc.response) -&gt; int -&gt; int -&gt; int
  end = CalcInterface(Idl.GenClientExn ())</code></pre><p>and <code>GenClientExnRpc</code> allows one to specify the rpc function once when constructing the client module:</p><pre><code class="ml">module CalcClient :
  sig
    val add : int -&gt; int -&gt; int
    val mul : int -&gt; int -&gt; int
  end = CalcInterface(Idl.GenClientExnRpc (struct let rpc = rpc end))</code></pre><p>Bindings for a server can be generated in a similar way:</p><pre><code class="ml">module CalcServer :
  sig
    val add : (int -&gt; int -&gt; (int, Idl.DefaultError.t) result) -&gt; unit
    val mul : (int -&gt; int -&gt; (int, Idl.DefaultError.t) result) -&gt; unit
    val implementation : Idl.server_implementation
  end = CalcInterface(Idl.GenServer ())</code></pre><p>The implementations of each RPC method should be specified by passing it to the corresponding function in <code>CalcServer</code>:</p><pre><code class="ml">CalcServer.add (fun a b -&gt; Ok (a + b));
CalcServer.mul (fun a b -&gt; Ok (a * b));</code></pre><p>Then we can generate our server from the <code>implementation</code> \(in case of <code>GenClient</code>, <code>implementation</code> is unused\):</p><pre><code class="ml">let rpc : (Rpc.call -&gt; Rpc.response) = Idl.server CalcServer.implementation</code></pre><p>Again, the transport mechanism is not implemented by <code>CalcServer</code>. We just get an rpc function that, given an <code>Rpc.call</code>, calls the implementation of that RPC method and performs the marshalling and unmarshalling. It is up to the user of this library to connect this <code>rpc</code> function to a real server that responds to client requests.</p><p>Here we also have a <code>GenServerExn</code> functor, for server implementations that raise exceptions instead of returning a <code>result</code>.</p><p>The <code>rpclib-lwt</code> and <code>rpclib-async</code> packages provide similar client and server generators that use <code>Lwt</code> and <code>Async</code>, respectively.</p><p>The <code>Xmlrpc</code> and <code>Jsonrpc</code> modules can be helpful when implementing the <code>rpc</code> function for an XML-RPC or JSON-RPC client/server: they provide functions for converting rpc requests and responses to/from their respective wire formats.</p><ul><li><p>Commandline interfaces can be generated using <code>Cmdlinergen</code>:</p><pre><code class="ml">module CalcCli :
  sig
    val implementation :
      unit -&gt;
      ((Rpc.call -&gt; Rpc.response) -&gt;
       (unit -&gt; unit) Cmdliner.Term.t * Cmdliner.Term.info)
      list
  end = CalcInterface(Cmdlinergen.Gen ())</code></pre><p>We can use the <code>implementation</code> to construct the CLI. Again, we need to pass an <code>rpc</code> function that knows how to make RPC calls.</p><pre><code class="ml">let () =
  let cmds = (List.map (fun t -&gt; t rpc) (CalcCli.implementation ())) in
  let open Cmdliner in
  Term.(exit @@ eval_choice default_cmd cmds)</code></pre></li><li>Some generators use the output of <code>Codegen</code>. This functor generates a structure that contains information about the methods, their parameters, return types, etc. Currently these generators that use the output of <code>Codegen</code> require the method parameters to be named.</li></ul><pre><code class="ml">module CalcInterface(R : Idl.RPC) = struct
  open R

  let int_p_1 = Idl.Param.mk ~name:&quot;int1&quot; Rpc.Types.int
  let int_p_2 = Idl.Param.mk ~name:&quot;int2&quot; Rpc.Types.int
  let int_p = Idl.Param.mk Rpc.Types.int

  let add = R.declare &quot;add&quot;
      [&quot;Add two numbers&quot;]
      (int_p_1 @-&gt; int_p_2 @-&gt; returning int_p Idl.DefaultError.err)

  let implementation = implement
      { Idl.Interface.name = &quot;Calc&quot;; namespace = Some &quot;Calc&quot;; description = [&quot;Calculator supporting addition and multiplication&quot;]; version = (1,0,0) }
end

module CalcCode :
  sig
    val implementation : unit -&gt; Codegen.Interface.t
  end = CalcInterface(Codegen.Gen ())

let interfaces = Codegen.Interfaces.create
  ~name:&quot;calc&quot;
  ~title:&quot;Calculator&quot;
  ~description:[&quot;Interface for a Calculator&quot;]
  ~interfaces:[CalcCode.implementation ()]</code></pre><ul><li><p><code>Markdowngen</code> can generate a markdown file documenting these interfaces:</p><pre><code class="ml">let md = Markdowngen.to_string interfaces</code></pre></li><li><p><code>Pythongen</code> can generate Python code that contains various classes wrapping a Python implementation, providing typechecking &amp;amp; method dispatch, and a CLI.</p><pre><code class="ml">let code = Pythongen.of_interfaces interfaces |&gt; Pythongen.string_of_ts</code></pre></li></ul><p>The possibilities are not limited to the above generators provided by <code>ocaml-rpc</code>. Any third-party module implementing the <code>RPC</code> signature can be used to generate something from an interface defined following the above pattern. For example, it is possible to write an <code>RPC</code> implementation that generates a GUI for a given interface.</p></div></body></html>